# Лабораторные работы по космической геодезии
# Работа 5.
# Усольцев Артём, ПГ-31, 2023 год
# Вариант 11
########################################################################################################################

import numpy as np
from math import sqrt
c = 299792.458  # speed of light, km/s

### Вариант 11
XYZk = np.array(
    [[-7_913.3673, -13_982.7246, 21_318.4703],
     [-16_687.2200, 20_528.9203, -1_039.0270],
     [14_839.2133, -5_110.2340, 21_157.0622],
     [16_428.9784, 16_337.6999, 13_713.2936],
     [-18_580.7353, -5_575.3946, 17_835.5689]]
)
R0 = np.array(
    [[453.0, 3638.0, 5201.0]]
)
rover1 = np.array(
    [[25_304.077],
     [24_860.668],
     [23_197.133],
     [22_112.708],
     [24_634.068]]
)
### Вариант 10
# XYZk = np.array(
#     [[15_016.4745, -4_873.2712, 21_083.9388],
#      [16_382.6999, 16_159.3121, 13_976.1087],
#      [-18_701.7736, -5_793.7280, 17_639.0443],
#      [-7_896.5183, 24_908.8834, -1_077.6882],
#      [-17_458.6142, 5_236.3465, 19_630.4816]]
# )
# R0 = np.array(
#     [[453.0, 3638.0, 5201.0]]
# )
# rover1 = np.array(
#     [[23_169.383],
#      [22_080.297],
#      [24_710.395],
#      [23_697.539],
#      [23_056.675]]
# )
########################################################################################################################

### Данные из примера
# XYZk = np.array(
#     [[-17_263.7861, 4_742.0874, 19_923.0056],
#      [-18_822.6372, -6_009.0440, 17_438.0388],
#      [15_373.4199, -4_404.9867, 20_921.6182],
#      [16_243.8233, 15_602.8117, 14_744.3224],
#      [-8_761.6272, 13_850.7176, 21_060.7451]]
# )
# # rover1 preliminary position
# R0 = np.array(
#     [[453.5], [3638.3], [5200.7]]
# )
# rover1 = np.array(
#     [[23_062.1089],
#      [24_787.0364],
#      [23_118.4326],
#      [21_990.4531],
#      [20_993.8943]]
# )
# ########################################################################################################################

########################################################################################################################
##############################################                 #########################################################
##############################################     РЕШЕНИЕ     #########################################################
##############################################                 #########################################################
########################################################################################################################

pk0 = np.array([
    [sqrt(
        (XYZk.item(0, 0) - R0.item(0)) ** 2 + (XYZk.item(0, 1) - R0.item(1)) ** 2 + (XYZk.item(0, 2) - R0.item(2)) ** 2
    )],
    [sqrt(
        (XYZk.item(1, 0) - R0.item(0)) ** 2 + (XYZk.item(1, 1) - R0.item(1)) ** 2 + (XYZk.item(1, 2) - R0.item(2)) ** 2
    )],
    [sqrt(
        (XYZk.item(2, 0) - R0.item(0)) ** 2 + (XYZk.item(2, 1) - R0.item(1)) ** 2 + (XYZk.item(2, 2) - R0.item(2)) ** 2
    )],
    [sqrt(
        (XYZk.item(3, 0) - R0.item(0)) ** 2 + (XYZk.item(3, 1) - R0.item(1)) ** 2 + (XYZk.item(3, 2) - R0.item(2)) ** 2
    )],
    [sqrt(
        (XYZk.item(4, 0) - R0.item(0)) ** 2 + (XYZk.item(4, 1) - R0.item(1)) ** 2 + (XYZk.item(4, 2) - R0.item(2)) ** 2
    )]
])

ek_X = np.array([
    [(XYZk.item(0, 0) - R0.item(0)) / pk0.item(0)],
    [(XYZk.item(1, 0) - R0.item(0)) / pk0.item(1)],
    [(XYZk.item(2, 0) - R0.item(0)) / pk0.item(2)],
    [(XYZk.item(3, 0) - R0.item(0)) / pk0.item(3)],
    [(XYZk.item(4, 0) - R0.item(0)) / pk0.item(4)],
])
ek_Y = np.array([
    [(XYZk.item(0, 1) - R0.item(1)) / pk0.item(0)],
    [(XYZk.item(1, 1) - R0.item(1)) / pk0.item(1)],
    [(XYZk.item(2, 1) - R0.item(1)) / pk0.item(2)],
    [(XYZk.item(3, 1) - R0.item(1)) / pk0.item(3)],
    [(XYZk.item(4, 1) - R0.item(1)) / pk0.item(4)],
])
ek_Z = np.array([
    [(XYZk.item(0, 2) - R0.item(2)) / pk0.item(0)],
    [(XYZk.item(1, 2) - R0.item(2)) / pk0.item(1)],
    [(XYZk.item(2, 2) - R0.item(2)) / pk0.item(2)],
    [(XYZk.item(3, 2) - R0.item(2)) / pk0.item(3)],
    [(XYZk.item(4, 2) - R0.item(2)) / pk0.item(4)],
])

A = np.array([
    [-ek_X.item(0), -ek_Y.item(0), -ek_Z.item(0), 1],
    [-ek_X.item(1), -ek_Y.item(1), -ek_Z.item(1), 1],
    [-ek_X.item(2), -ek_Y.item(2), -ek_Z.item(2), 1],
    [-ek_X.item(3), -ek_Y.item(3), -ek_Z.item(3), 1],
    [-ek_X.item(4), -ek_Y.item(4), -ek_Z.item(4), 1],
])
A_t = A.transpose()
N = np.matmul(A_t, A)
Q = np.linalg.inv(N)
l = pk0 - rover1
L = np.matmul(A.transpose(), l)
X = np.matmul(-Q, L)  # dR_j & b_j
v = np.matmul(A, X) + l
dX_j = X.item(0)
dY_j = X.item(1)
dZ_j = X.item(2)
b_j = X.item(3)

# Поправка в предварительное положение ровера
dR_j = np.array(
    [[dX_j],
     [dY_j],
     [dZ_j]]
)

R_j = R0.transpose() + dR_j  # Координаты пункта
dt_j = b_j / c  # Сдвиг шкалы часов приёмника

### Оценка точности
k = 1
mu = np.sqrt(
    np.divide(np.matmul(v.transpose(), v), k)  # Ошибка единицы веса
)
m_x = mu * sqrt(Q.item(0))
m_y = mu * sqrt(Q.item(5))
m_z = mu * sqrt(Q.item(10))
m_T = mu / c * sqrt(Q.item(15))
M = sqrt(m_x ** 2 + m_y ** 2 + m_z ** 2)

print(R_j)
