# Лабораторные работы по космической геодезии
# Работа 1. Координатные системы отсчёта и системы времени при решении задач космической геодезии
# Усольцев Артём, ПГ-31, 2023 год
# Вариант 3
########################################################################################################################
from math import sin, cos, sqrt, radians, degrees, atan, acos, asin, tan, pi
import matplotlib.pyplot as plt
from PIL import Image
import numpy as np

# Исходные данные
R_0 = 6371.21  # * 1000  # km
S_0 = radians(2 + 41 / 60 + 50.55 / 3600) * 15  # hms
gamma_0 = radians(10)
mu = 398600.5
########################################################################################################################
# Вариант 3 - мой, настоящий
x = 2882.29  # km
y = 6174.61  # km
z = -631.55  # km
t_0 = radians(20 + 36 / 60 + 14.56 / 3600) * 15  # hms
nu = radians(338)
c = 56797.90  # km
e = 0.19
xyz = np.array([[x],
                [y],
                [z]])
########################################################################################################################
########################################################################################################################
########################################################################################################################
################################################# РЕШЕНИЕ ##############################################################
########################################################################################################################
########################################################################################################################

# 1. Вычислить гринвичское звёздное время на момент t_0
S = S_0 + 1.00273 * t_0  # Этот коэффициент для радианов, всё верно.
########################################################################################################################

# 2. Геоцентрические координаты в земной СК
R = np.array([[x * cos(S) + y * sin(S)],
              [-x * sin(S) + y * cos(S)],
              [z]])
X = R.item(0)
Y = R.item(1)
Z = R.item(2)
########################################################################################################################

# 3. Сферические координаты подспутниковой точки
phi_0 = atan(Y / X)
lambda_0 = atan(Z / sqrt(X ** 2 + Y ** 2))
########################################################################################################################

# 4. Угловой размер зоны видимости
h = sqrt(X ** 2 + Y ** 2 + Z ** 2) - R_0
beta = acos(
    (R_0 / (R_0 + h)) * cos(gamma_0)
) - gamma_0


########################################################################################################################

# 5. Граничные значения phi и lambda
def draw_zone():
    # A = [0, 45, 90, 135, 180, 225, 270, 315]
    A = range(0, 360)
    phi_i = []
    lambda_i = []
    for A in A:
        phi_elem = asin(
            sin(phi_0) * cos(beta) + cos(phi_0) * sin(beta) * cos(radians(A))
        )
        lambda_elem = lambda_0 + asin(
            (sin(beta) / cos(phi_elem)) * sin(radians(A))
        )
        phi_i.append(round(degrees(phi_elem), 10))
        lambda_i.append(round(degrees(lambda_elem), 10))
    # earth_mercator = np.asarray(Image.open('../img/mercator.png'))
    # img_plot = plt.imshow(earth_mercator)
    xcpoints = [-180, -180, 180, 180]
    ycpoints = [-90, 90, -90, 90]
    plt.plot(phi_i, lambda_i, 'ro')
    plt.plot(xcpoints, ycpoints, 'ro')
    plt.plot()
    plt.show()


draw_zone()

# 6. Время прохождения спутника в зоне видимости
### Среднее движение спутника вычисляется по формуле:
a = (c ** 2) / (mu * (1 - e ** 2))
n = radians(sqrt(mu / a ** 3) * (180 / pi))


def quarter_check(val):
    """
    По своей сути, исключает ситуацию, когда значение \nu приводит к тому, что значение E_i оказывается отрицательным.
    """
    _x = sin(val / 2)
    _y = cos(val / 2)
    if _x < 0:
        return val + pi
    elif _x > 0 and _y <= 0:
        return val + 2 * pi
    else:
        return val


nu_1 = quarter_check(nu - beta)
nu_2 = quarter_check(nu + beta)

E_1 = 2 * atan(
    sqrt((1 - e) / (1 + e)) * tan(nu_1 / 2)
)
E_2 = 2 * atan(
    sqrt((1 - e) / (1 + e)) * tan(nu_2 / 2)
)
E = 2 * atan(
    sqrt((1 - e) / (1 + e)) * tan(nu / 2)
)

M_1 = E_1 - e * sin(E_1)
M_2 = E_2 - e * sin(E_2)
M = E - e * sin(E)

t_pi = t_0 - radians((M / n) / 3600 * 15)

t_1 = degrees(t_pi + radians((M_1 / n) / 3600 * 15)) / 15
t_2 = degrees(t_pi + radians((M_2 / n) / 3600 * 15)) / 15

delta_t = t_2 - t_1
