# Лабораторные работы по космической геодезии
# Работа 1. Координатные системы отсчёта и системы времени при решении задач космической геодезии
# Усольцев Артём, ПГ-31, 2023 год
# Вариант 3
########################################################################################################################
from math import sin, cos, sqrt, atan
import numpy as np
import pprint

pp = pprint.PrettyPrinter(indent=3)
np.set_printoptions(suppress=True, precision=10)

##### Исходные данные ##################################################################################################
# item(0) - X, item(1) - Y
# Local coordinate system:
p1_usk = [121_048.55, 46_575.12]
p2_usk = [123_151.06, 45_248.09]
p3_usk = [122450.78, 48316.81]
p4_usk = [120068.23, 47022.95]
# SK95 coordinate system:
p1_sk95 = [6_112_606.71, 564_356.21]
p2_sk95 = [6_114_885.82, 563_362.62]
########################################################################################################################

########################################################################################################################
##############################################                 #########################################################
##############################################     РЕШЕНИЕ     #########################################################
##############################################                 #########################################################
########################################################################################################################

##### 1. Вычисляется предварительное значение угла поворота ############################################################
# Direction in SK95
Beta_95 = atan(
    (p2_sk95[1] - p1_sk95[1]) /
    (p2_sk95[0] - p1_sk95[0])
)
# Direction in local system
Beta_usk = atan(
    (p2_usk[1] - p1_usk[1]) /
    (p2_usk[0] - p1_usk[0])
)

gamma_0 = Beta_95 - Beta_usk  # Предварительное значение угла
########################################################################################################################

##### 2. Составляется таблица коэффициентов и свободных членов уравнений поправок (четыре уравнения). ##################
# Матрица коэффициентов уравнений поправок
A = np.array(
    [[1, 0, -(sin(gamma_0) * p1_usk[0] + cos(gamma_0) * p1_usk[1])],
     [0, 1, cos(gamma_0) * p1_usk[0] - sin(gamma_0) * p1_usk[1]],
     [1, 0, -(sin(gamma_0) * p2_usk[0] + cos(gamma_0) * p2_usk[1])],
     [0, 1, cos(gamma_0) * p2_usk[0] - sin(gamma_0) * p2_usk[1]]]
)

# Вектор свободных членов
l = np.array(
    [[p1_usk[0] * cos(gamma_0) - p1_usk[1] * sin(gamma_0) - p1_sk95[0]],  # lx по 1 точке
     [p1_usk[0] * sin(gamma_0) + p1_usk[1] * cos(gamma_0) - p1_sk95[1]],  # ly по 1 точке
     [p2_usk[0] * cos(gamma_0) - p2_usk[1] * sin(gamma_0) - p2_sk95[0]],  # lx по 2 точке
     [p2_usk[0] * sin(gamma_0) + p2_usk[1] * cos(gamma_0) - p2_sk95[1]]]  # ly по 2 точке
)
########################################################################################################################

##### 3. Решается переопределенная система уравнений поправок, и находятся три неизвестных #############################
A_t = np.transpose(A)
part1 = np.linalg.inv(np.matmul(A_t, A))
part2 = np.matmul(A_t, l)

X_accent = np.matmul(part1, part2) * -1  # Вектор параметров сдвига и поворота систем

dx = X_accent.item(0)  # Сдвиг системы относительно x
dy = X_accent.item(1)  # Сдвиг системы относительно y
dgamma = X_accent.item(2)
gamma = gamma_0 + dgamma  # Полный угол поворота системы
########################################################################################################################

###### 4. Производится вычисление координат всех точек из системы УСК в систему СК-42 по формулам (1). На двух #########
###### исходных точках делается контроль преобразования координат. #####################################################
vx_p1 = dx - p1_usk[0] * sin(gamma_0) * dgamma - p1_usk[1] * cos(gamma_0) * dgamma + l.item(0)
vy_p1 = dy + p1_usk[0] * cos(gamma_0) * dgamma - p1_usk[1] * sin(gamma_0) * dgamma + l.item(1)
vx_p2 = dx - p2_usk[0] * sin(gamma_0) * dgamma - p2_usk[1] * cos(gamma_0) * dgamma + l.item(2)
vy_p2 = dy + p2_usk[0] * cos(gamma_0) * dgamma - p2_usk[1] * sin(gamma_0) * dgamma + l.item(3)
v = np.array([  # Вектор остаточных невязок
    [vx_p1],
    [vy_p1],
    [vx_p2],
    [vy_p2]
])

Q_X = np.linalg.inv(np.matmul(A_t, A))  # Корреляционная матрица
v_t = np.transpose(v)
k = 1  # Количество избыточных измерений TODO: сколько?
mu = np.sqrt(
    np.divide(np.matmul(v_t, v), k)  # Ошибка единицы веса
)

m_x = mu * sqrt(Q_X.item(0))  # Ошибка по x (m)
m_y = mu * sqrt(Q_X.item(4))  # Ошибка по y (m)
m_gamma = mu * sqrt(Q_X.item(8))  # Ошибка угла поворота (rads)
m = np.array([[m_x], [m_y], [m_gamma]])  # Вектор ошибок неизвестных
########################################################################################################################


# Вычисление координат
def transform_usk_to_sk95(point: list):
    dx_dy = np.array(
        [[dx],
         [dy]]
    )
    input_point = np.array(
        [[point[0]],
         [point[1]]]
    )
    rotate_matrix = np.array(
        [[cos(gamma), -sin(gamma)],
         [sin(gamma), cos(gamma)]]
    )
    output = dx_dy + np.matmul(rotate_matrix, input_point)
    return output


pp.pprint(m)
